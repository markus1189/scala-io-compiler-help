\documentclass{beamer}

\usepackage{minted}
\usepackage{pgf}
\usepackage[utf8]{inputenc}
\usepackage{mdframed}

\BeforeBeginEnvironment{minted}{\begin{mdframed}}
\AfterEndEnvironment{minted}{\end{mdframed}}

\title{Let The Compiler Help You: How To Make The Most Of Scala's Typesystem}
\author{Markus Hauck (@markus1189)}

\date{Scala.IO 2017}
\subject{Computer Science}
\usetheme{codecentric}

\renewcommand\texttt[1]{\mintinline{scala}/#1/}

\usemintedstyle{fruity}

\begin{document}

{
  \usebackgroundtemplate{\includegraphics[height=\paperheight]{background.jpg}}
  \frame[plain]{\titlepage}
}

\section{Intro}
\label{sec:intro}

\begin{frame}
  \begin{center}
    \frametitle{One Evening}
    \includegraphics[width=0.6\textwidth]{../pics/lets-program.png}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Done!?}
\begin{minted}{bash}
> compile
[success] Total time: 42s, completed Nov 2 14:05:42
> run
...
\end{minted}
\end{frame}

\begin{frame}
  \begin{center}
    \includegraphics[width=0.6\textwidth]{../pics/unsupported.png}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Done!?}
\begin{minted}{bash}
> compile
[success] Total time: 42s, completed Nov 2 14:05:42
> run
...
\end{minted}
\end{frame}

\begin{frame}
  \begin{center}
    \includegraphics[width=0.6\textwidth]{../pics/iae.png}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \includegraphics[width=0.6\textwidth]{../pics/told-you.png}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A Better Way}
\begin{minted}[fontsize=\footnotesize]{bash}
> compile
[info] Compiling 1 Scala source to 
  /home/brain/world-domination/target/scala-2.12/classes ...
[error] ConquerWorld.scala:1337:42: type mismatch;
[error]  found   : Int(-42)
[error]  required: PositiveInt
[error]   requiredAssets(-42)
[error]        ^
[error] one error found
[error] (compile:compileIncremental) Compilation failed
\end{minted}
\end{frame}

\begin{frame}
  \begin{center}
    \includegraphics[width=0.6\textwidth]{../pics/good-compiler.png}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Introduction}
  \begin{itemize}
  \item Java: fight the stupid compiler and the types
  \item Better: cooperate with the compiler!
  \item To get the most help, you need to communicate with
    the compiler
  \item this talk: how to become friends with the compiler
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Become Friends}
  \begin{itemize}
  \item Turns out the compiler is only there to help
  \item He wants you to succeed, not prevent you to
  \item You should write your code in a way that the compiler can do
    the most for you
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Road Ahead}
  \begin{itemize}
  \item We will start slowly and pickup speed
  \item 0: Don't lie
  \item 1: Don't lie
  \item 2: TODO
  \item 3: TODO
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Disclaimer: The Compiler. Does. Not. Read. Documentation}
  \begin{itemize}
  \item documentation is NOT a way to talk to your compiler
  \item (and probably neither to your coworkers)
  \item also to avoid: \textbf{context sensitive} reasoning
  \item think: I \textbf{know} this can't happen
  \item use a language that the compiler understands: types
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{itemize}
  \item refer to https://bartoszmilewski.com/2014/11/24/types-and-functions/
  \end{itemize}
%   Who Needs Types?

% There seems to be some controversy about the advantages of static vs. dynamic and strong vs. weak typing. Let me illustrate these choices with a thought experiment. Imagine millions of monkeys at computer
% keyboards happily hitting random keys, producing programs, compiling, and running them.

                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
% IMG_1329                     

% With machine language, any combination of bytes produced by monkeys would be accepted and run. But with higher level languages, we do appreciate the fact that a compiler is able to detect lexical and grammatical
% errors. Lots of monkeys will go without bananas, but the remaining programs will have a better chance of being useful. Type checking provides yet another barrier against nonsensical programs. Moreover, whereas
% in a dynamically typed language, type mismatches would be discovered at runtime, in strongly typed statically checked languages type mismatches are discovered at compile time, eliminating lots of incorrect
% programs before they have a chance to run.

% So the question is, do we want to make monkeys happy, or do we want to produce correct programs?

% The usual goal in the typing monkeys thought experiment is the production of the complete works of Shakespeare. Having a spell checker and a grammar checker in the loop would drastically increase the odds. The
% analog of a type checker would go even further by making sure that, once Romeo is declared a human being, he doesnâ€™t sprout leaves or trap photons in his powerful gravitational field.
\end{frame}

\section{Step 0: Open Lines}

\begin{frame}
  \frametitle{Open Lines}
  \begin{itemize}
  \item THE COMPILER IS SHY: ENCOURAGE TO SPEAK
  \item by default, the compiler will not tell you everything
  \item enable flags to make it talk
  \item recommended: ...
  \end{itemize}
\end{frame}

\section{Step 1: Don't Lie}

\begin{frame}[c]
  \begin{center}
    \Large Step 1: Don't lie about what you CAN do
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Get The Max Out Of Your List}
  \includegraphics[width=0.8\textwidth]{../pics/list-max.png}
\end{frame}

\begin{frame}[fragile,fragile]
  \frametitle{Putting It Into Practice}
  \begin{minted}{scala}
> List[Int](1, 2, 3).max
res0: Int = 3
\end{minted}
\begin{minted}{scala}
> List[Int]().max                                                             
java.lang.UnsupportedOperationException: empty.max                                 
\end{minted}
\end{frame}

\begin{frame}
  \frametitle{Step 1: Don't lie about what you can do}
  \begin{itemize}
  \item The compiler can't help you if you lie
  \item How to tell the truth:
    \begin{itemize}
    \item Option
    \item Either
    \item Custom ADT
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Communication is Everything}
  \begin{itemize}
  \item communicate absence: Option
  \item communicate error vs success: Either/Validated/IOr
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{A better max}
  
\end{frame}

\section{Step 2: Forbid It}

\begin{frame}[fragile]
  \frametitle{If not allowed, FORBID it}
\begin{minted}{scala}
case class Email(value: String) extends AnyVal {
  require(isValidEmail(value))
}
\end{minted}
\begin{minted}{scala}
> Email("markus.hauck@codecentric.de")
res1: Email = ...
> Email("Hello World!")
java.lang.IllegalArgumentException: 
  Not a valid email address                      
\end{minted}
\end{frame}

\begin{frame}[fragile,fragile]
  \frametitle{If not allowed, FORBID it}
\begin{minted}{scala}
abstract case class Email private (...)

object Email {
  def fromString: Either[ValidationError, Email] = 
    ??? // exercise
}
\end{minted}

\begin{minted}{scala}
> Email.fromString("markus.hauck@codecentric.de")
res1: Either[ValidationError, Email] = 
  Right("markus.hauck@codecentric.de")

> Email.fromString("Hello World")
res2: Either[ValidationError, Email] = 
  Left(InvalidEmail)
\end{minted}
\end{frame}

\begin{frame}
  \frametitle{Ensure Simple Invariants}
  \begin{itemize}
  \item let's start with ensuring invariants
  \item two ways to react to invalid input:
    \begin{itemize}
    \item signal error (as return value)
    \item better: don't allow invalid input!
    \end{itemize}
  \end{itemize}
\end{frame}

\section{Step 3: No Garbage}

\begin{frame}
  \frametitle{Step 3: Don't accept garbage}
  \includegraphics[width=\textwidth]{../pics/scrapyard-2441432_1280.jpg}
\end{frame}

\begin{frame}
  \frametitle{Avoid Invalid Instantiation}
  \begin{itemize}
  \item require/assert/exceptions = bad
  \item better: use custom instantiation methods
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Don't accept garbage as your input}
   \begin{itemize}
  \item previously: accept arguments, maybe fail
  \item but: we did nothing wrong!  It's the caller's fault!
  \item use types to only accept valid input
  \item (this is a trade-off and cannot be done for all args)
  \item negative int, empty collection and more
  \item how to enforce?
    \begin{itemize}
    \item custom classes with smart constructors
    \item if possible use libraries
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Pushing Boundaries}
  \begin{itemize}
  \item we shift the responsiblity to another place
  \item good: separate \textit{validation} from actual program
  \item goal: push it to the boundaries and deal with it \textbf{once}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,fragile]
  \frametitle{Putting It Into Practice}
\begin{minted}{scala}
def sendEmail(mail: String): 
  Either[MailValidationError, MailStatus]
// vs
def sendEmail(mail: Email): 
  MailStatus
\end{minted}
\begin{minted}{scala}
> NonEmptyList.of(1, 2, 3).head
res1: Int = 1
\end{minted}
\end{frame}

\begin{frame}
  \frametitle{Phantom Types for Tags}
  \begin{itemize}
  \item Creating new classes for invariants works, but very cumbersome
  \item But: Whenever input enters your system: require validation
  \item Avoid validation again and again because of different flows
    through system and refactorings (context-free!)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Refined}
  \begin{itemize}
  \item Indexing into collections
  \item Creating e.g. Versions from Strings
  \item Calculate average on empty list?
  \item Validation should happen \textbf{at the boundaries} (once and
    for all)
  \end{itemize}
\end{frame}

\section{Step 4: No Inconsistent States}

\begin{frame}
  \frametitle{Types As Documentation}
  \begin{itemize}
  \item common pattern: builders and state machines
  \item problem: invariants / minimal set of attributes / conflicting
    methods
  \item goal: only allow correct usage
  \item (without using inheritance)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Types As Documentation}
  \begin{itemize}
  \item phantom types + subtyping
  \item model the ``states'' as a type, use bounds to constrict
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Phantom Types for State Machines}
  \begin{itemize}
  \item Given a state machine type of flow, we can represent that with
    types!
  \item Use subtyping to model your graph
  \item typical example: the builder
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{State Machine}
  \begin{itemize}
  \item example: vending machine
    %TODO: insert graphical image here
  \item actions:
    \begin{itemize}
    \item insert 50 cents
    \item abort and return change
    \item extract item
    \end{itemize}
  \item constraints:
    \begin{itemize}
    \item you can only insert 50 cents twice
    \item extraction is not possible until paid
    \item abort can only be used before confirm
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{State Machine}
  \begin{itemize}
  \item let's express that in code:
  \end{itemize}

\begin{minted}{scala}

\end{minted}
\end{frame}

\begin{frame}
  \frametitle{State Machines: Summary}
  \begin{itemize}
  \item alternative to inheritance, but more ligthweight (instead of
    creating classes for all states)
  \item does not allow invalid state
  \end{itemize}
\end{frame}

\section{Step 5: Calculate Types}

\begin{frame}
  \frametitle{Returning Goods}
  \begin{itemize}
  \item our vending machine only produced one type of good
  \item let's extend the machine:
    \begin{itemize}
    \item after inserting fifty cents, calling extract dispenses XXX
    \item after inserting one euro, calling extract dispenses YYY
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Returning Goods}
  \begin{itemize}
  \item if we look at our extraction method:
  \end{itemize}

\begin{minted}{scala}
def extract : ??? // outcome depends on the state!
\end{minted}

  \begin{itemize}
  \item out \texttt{return type} depends on the current state!
  \item solution: calculate return type from our state.  How?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Compiler Is There To Help!}
  \vfill
  \begin{center}
    {\Huge THANKS!}
  \end{center}
\end{frame}

\end{document}
