\documentclass{beamer}

\usepackage{minted}
\usepackage{pgf}
\usepackage[utf8]{inputenc}
\usepackage{mdframed}

\BeforeBeginEnvironment{minted}{\begin{mdframed}}
  \AfterEndEnvironment{minted}{\end{mdframed}}

\title{Let The Compiler Help You: How To Make The Most Of Scala's Typesystem}
\author{Markus Hauck (@markus1189)}

\date{Scala.IO 2017}
\subject{Computer Science}
\usetheme{codecentric}

\renewcommand\texttt[1]{\mintinline{scala}/#1/}

\usemintedstyle{fruity}

\begin{document}

{
  \usebackgroundtemplate{\includegraphics[height=\paperheight]{background.jpg}}
  \frame[plain]{\titlepage}
}

\section{Intro}
\label{sec:intro}

\begin{frame}
  \begin{center}
    \frametitle{One Evening}
    \includegraphics[width=0.6\textwidth]{../pics/lets-program.png}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Done!?}
\begin{minted}{bash}
> compile
[success] Total time: 42s, completed Nov 2 14:05:42
> run
...
\end{minted}
\end{frame}

\begin{frame}
  \begin{center}
    \includegraphics[width=0.6\textwidth]{../pics/unsupported.png}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Done!?}
\begin{minted}{bash}
> compile
[success] Total time: 42s, completed Nov 2 14:05:42
> run
...
\end{minted}
\end{frame}

\begin{frame}
  \begin{center}
    \includegraphics[width=0.6\textwidth]{../pics/iae.png}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \includegraphics[width=0.6\textwidth]{../pics/told-you.png}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{A Better Way}
\begin{minted}[fontsize=\footnotesize]{bash}
> compile
[info] Compiling 1 Scala source to 
  /home/brain/world-domination/target/scala-2.12/classes ...
[error] ConquerWorld.scala:1337:42: type mismatch;
[error]  found   : Int(-42)
[error]  required: PositiveInt
[error]   requiredAssets(-42)
[error]        ^
[error] one error found
[error] (compile:compileIncremental) Compilation failed
\end{minted}
\end{frame}

\begin{frame}
  \begin{center}
    \includegraphics[width=0.6\textwidth]{../pics/good-compiler.png}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Introduction}
  \begin{itemize}
  \item currently: programming as a fight against the compiler
  \item soon: work together with the compiler
  \item tests: \textbf{evidence} it works
  \item types: \textbf{proof} it works
  \item you need to communicate with the compiler
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Become Friends}
  \begin{itemize}
  \item by default the compiler is a little shy
  \item but once you get friends, you don't want to go back
  \item bla bla bla
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Road Ahead}
  \begin{itemize}
  \item We will start slowly and pickup speed
  \item 0: Don't lie
  \item 1: Don't lie
  \item 2: TODO
  \item 3: TODO
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Not: Documentation}
  \begin{itemize}
  \item documentation is not for the compiler
  \item it is meant for humans (which are bad at it)
  \item avoid: \textbf{context sensitive} reasoning
  \item think: I \textbf{know} this can't happen
  \item use a language that the compiler understands: types
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{itemize}
  \item refer to https://bartoszmilewski.com/2014/11/24/types-and-functions/
  \end{itemize}
  % Who Needs Types?

  % There seems to be some controversy about the advantages of static vs. dynamic and strong vs. weak typing. Let me illustrate these choices with a thought experiment. Imagine millions of monkeys at computer
  % keyboards happily hitting random keys, producing programs, compiling, and running them.

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  % IMG_1329                     

  % With machine language, any combination of bytes produced by monkeys would be accepted and run. But with higher level languages, we do appreciate the fact that a compiler is able to detect lexical and grammatical
  % errors. Lots of monkeys will go without bananas, but the remaining programs will have a better chance of being useful. Type checking provides yet another barrier against nonsensical programs. Moreover, whereas
  % in a dynamically typed language, type mismatches would be discovered at runtime, in strongly typed statically checked languages type mismatches are discovered at compile time, eliminating lots of incorrect
  % programs before they have a chance to run.

  % So the question is, do we want to make monkeys happy, or do we want to produce correct programs?

  % The usual goal in the typing monkeys thought experiment is the production of the complete works of Shakespeare. Having a spell checker and a grammar checker in the loop would drastically increase the odds. The
  % analog of a type checker would go even further by making sure that, once Romeo is declared a human being, he doesnâ€™t sprout leaves or trap photons in his powerful gravitational field.
\end{frame}

\section{Open Lines}

\begin{frame}
  \frametitle{Open Lines}
  \begin{itemize}
  \item THE COMPILER IS SHY: ENCOURAGE TO SPEAK
  \item by default, the compiler will not tell you everything
  \item enable flags to make it talk
  \item recommended: ...
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Case Study: Vending Machine}
  \begin{columns}
    \begin{column}{0.6\textwidth}
      \begin{itemize}
      \item insert coin (50 cents or 1 euro)
      \item push button for drink
      \item abort the transaction and return money
      \end{itemize}
    \end{column}
    \begin{column}{0.4\textwidth}
      \begin{center}
        \includegraphics[width=\textwidth]{../pics/vending.jpg}
      \end{center}

    \end{column}
  \end{columns}
\end{frame}

\begin{frame}
  \inputminted[fontsize=\small, firstline=3]{scala}{../src/main/scala/de/codecentric/zero/VendingMachine.scala}
\end{frame}

\begin{frame}
  \frametitle{A First Design}
  \begin{itemize}
  \item what does the compiler know?
  \item what do you as a user of this class know without docs?
  \end{itemize}
    \begin{center}
    \includegraphics[width=0.4\textwidth]{../pics/docs.jpg}
  \end{center}
  \begin{itemize}
  \item let's see how we can improve on this!
  \end{itemize}

\end{frame}

\section{Be Honest}

\begin{frame}
  \frametitle{Step 1: Be Honest}
  \begin{center}
    \includegraphics[width=\textwidth]{../pics/dog.jpg}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Get The Max Out Of Your List}
  \includegraphics[width=0.8\textwidth]{../pics/list-max.png}
\end{frame}

\begin{frame}[fragile,fragile]
  \frametitle{Get The Max Out Of Your List}
\begin{minted}{scala}
> List[Int](1, 2, 3).max
res0: Int = 3
\end{minted}
\begin{minted}{scala}
> List[Int]().max                                                             
java.lang.UnsupportedOperationException: empty.max                                 
\end{minted}
\end{frame}

\begin{frame}
  \frametitle{Be Honest}
  \begin{itemize}
  \item The compiler can't help you if you are not honest
  \item \texttt{max} pretends to always return something, which is not
    the case!
  \item tell the compiler this operation can fail
  \item Option: if no result is a result
  \item Either: if there can be errors
  \item Custom ADT:\@if \texttt{Either} doesn't cut it
  \end{itemize}
\end{frame}

\section{Forbid It}

\begin{frame}
  \frametitle{Step 3: If not allowed, forbid it}
  \begin{center}
    \includegraphics[width=0.5\textwidth]{../pics/forbidden.png}
  \end{center}
\end{frame}

\begin{frame}[fragile,fragile]
  \frametitle{Step 3: If not allowed, forbid it}
  \begin{itemize}
  \item \textbf{every} project has domain classes with invariants
  \item how to verify those invariants?
  \end{itemize}
\begin{minted}{scala}
if (input.isValid) {
  ???
} else {
  throw new Exception("whoopsie")
}
\end{minted}
\begin{minted}{scala}
class ImportantStuff(stuff: Stuff) {
  require(stuff.isImportant, "Not important!")
}
\end{minted}
  \begin{itemize}
  \item but the compiler (and others) does not know this!
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{If not allowed, forbid it}
\begin{minted}{scala}
case class Email(value: String) extends AnyVal {
  require(isValidEmail(value))
}
\end{minted}
\begin{minted}{scala}
> Email("markus.hauck@codecentric.de")
res1: Email = ...

> Email("Hello World!")
java.lang.IllegalArgumentException: 
  Not a valid email address                      
\end{minted}
\end{frame}

\begin{frame}
  \frametitle{If not allowed, forbid it}
  \begin{itemize}
  \item how can we improve?
  \item for methods, the \textbf{return type} changed
  \item instantiation doesn't have one?
  \item one solution: smart constructors / factories
  \end{itemize}
\end{frame}

\begin{frame}[fragile,fragile]
  \frametitle{If not allowed, forbid it}
\begin{minted}{scala}
abstract case class Email private (...)

object Email {
  def fromString: Either[ValidationError, Email] = 
    ??? // exercise
}
\end{minted}

\begin{minted}{scala}
> Email.fromString("markus.hauck@codecentric.de")
res1: Either[ValidationError, Email] = 
  Right("markus.hauck@codecentric.de")

> Email.fromString("Hello World")
res2: Either[ValidationError, Email] = 
  Left(InvalidEmail)
\end{minted}
\end{frame}

\begin{frame}
  \frametitle{Case Study}
  \begin{itemize}
  \item Okay, back to our case study
  \item we want to fix:
    \begin{itemize}
    \item methods that are not honest
    \item forbid invalid instantiation
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile,c]
  
  \inputminted[fontsize=\small, firstline=3, lastline=22]{scala}{../src/main/scala/de/codecentric/two/VendingMachine.scala}
\end{frame}

\begin{frame}[fragile,c]
  \inputminted[fontsize=\small, firstline=24]{scala}{../src/main/scala/de/codecentric/two/VendingMachine.scala}
\end{frame}


\begin{frame}
  \frametitle{Case Study: Review}
  \begin{itemize}
  \item we got rid of all exceptions
  \item no way to ``forget'' that something can fail
  \item compiler (coworkers?) now knows quite a bit more
  \item what else can we improve?
  \end{itemize}
\end{frame}

\section{No Garbage}

\begin{frame}
  \frametitle{Step 3: Don't accept garbage}
  \includegraphics[width=\textwidth]{../pics/scrapyard-2441432_1280.jpg}
\end{frame}

\begin{frame}
  \frametitle{Don't accept garbage as your input}
  \begin{itemize}
    
  \item our constructor and methods are quite nice with us
  \item they take almost everything!
  \item does the validation really belong in our vending machine?
  \item actually it is the \textbf{caller}'s fault!
  \item better: don't accept garbage and let the caller to the work
  \item push validation to the boundaries of your system
  \item avoid doing it over and over again in program flow
  \end{itemize}
\end{frame}

\begin{frame}[fragile,fragile]
  \frametitle{Putting It Into Practice}
\begin{minted}{scala}
class MailService {
  def sendEmail(mail: String): 
    Either[MailValidationError, MailStatus]
}
\end{minted}

\begin{minted}{scala}
class MailService {
  def sendEmail(mail: Email): MailStatus
}
\end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Putting It Into Practice}
\begin{minted}{scala}
> List(1, 2, 3).head
res1: Option[Int] = Some(1)
\end{minted}
\begin{minted}{scala}
> NonEmptyList.of(1, 2, 3).head
res1: Int = 1
\end{minted}
\end{frame}

\begin{frame}[fragile,fragile]
  \frametitle{Putting It Into Practice}
\begin{minted}{scala}
sealed abstract class List[+A] {
  def apply(index: Int): A
}
\end{minted}

\begin{minted}{scala}
sealed abstract class List[+A] {
  def apply(index: Natural): A
}
\end{minted}
\end{frame}

\begin{frame}
  \frametitle{How To Validate}
  \begin{itemize}
  \item we have two choices
  \item use a new class with smart constructors
  \item use a \texttt{Tagged} and phantom types
  \end{itemize}
\end{frame}

\begin{frame}[fragile,fragile]
  \frametitle{Validation With Smart Constructors}
\begin{minted}{scala}
abstract case class Email private (...)

object Email {
  def fromString: Either[ValidationError, Email] = 
    ??? // exercise
}
\end{minted}
  \begin{itemize}
  \item that works, but becomes cumbersome pretty quick
  \item I \textbf{know} it will succeed!
  \end{itemize}
\begin{minted}{scala}
> Email.fromString("foo@bar.de")
\end{minted}
\end{frame}

\begin{frame}
  \frametitle{Phantom Types for Tags}
  \begin{itemize}
  \item Creating new classes for invariants works, but very cumbersome
  \item But: Whenever input enters your system: require validation
  \item Avoid validation again and again because of different flows
    through system and refactorings (context-free!)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Refined}
  \begin{itemize}
  \item Indexing into collections
  \item Creating e.g. Versions from Strings
  \item Calculate average on empty list?
  \item Validation should happen \textbf{at the boundaries} (once and
    for all)
  \end{itemize}
\end{frame}

\section{No Inconsistent States}

\begin{frame}
  \frametitle{Types As Documentation}
  \begin{itemize}
  \item common pattern: builders and state machines
  \item problem: invariants / minimal set of attributes / conflicting
    methods
  \item goal: only allow correct usage
  \item (without using inheritance)
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Types As Documentation}
  \begin{itemize}
  \item phantom types + subtyping
  \item model the ``states'' as a type, use bounds to constrict
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Phantom Types for State Machines}
  \begin{itemize}
  \item Given a state machine type of flow, we can represent that with
    types!
  \item Use subtyping to model your graph
  \item typical example: the builder
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{State Machine}
  \begin{itemize}
  \item example: vending machine
    % TODO: insert graphical image here
  \item actions:
    \begin{itemize}
    \item insert 50 cents
    \item abort and return change
    \item extract item
    \end{itemize}
  \item constraints:
    \begin{itemize}
    \item you can only insert 50 cents twice
    \item extraction is not possible until paid
    \item abort can only be used before confirm
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{State Machine}
  \begin{itemize}
  \item let's express that in code:
  \end{itemize}

\begin{minted}{scala}

\end{minted}
\end{frame}

\begin{frame}
  \frametitle{State Machines: Summary}
  \begin{itemize}
  \item alternative to inheritance, but more ligthweight (instead of
    creating classes for all states)
  \item does not allow invalid state
  \end{itemize}
\end{frame}

\section{Calculate Types}

\begin{frame}
  \frametitle{Returning Goods}
  \begin{itemize}
  \item our vending machine only produced one type of good
  \item let's extend the machine:
    \begin{itemize}
    \item after inserting fifty cents, calling extract dispenses XXX
    \item after inserting one euro, calling extract dispenses YYY
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Returning Goods}
  \begin{itemize}
  \item if we look at our extraction method:
  \end{itemize}

\begin{minted}{scala}
def extract : ??? // outcome depends on the state!
\end{minted}

  \begin{itemize}
  \item out \texttt{return type} depends on the current state!
  \item solution: calculate return type from our state.  How?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Compiler Is There To Help!}
  \vfill
  \begin{center}
    {\Huge THANKS!}
  \end{center}
\end{frame}

\end{document}
